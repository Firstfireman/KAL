// *********************************************************
//
// File autogenerated for the path_generator_ros_tool package
// by the rosinterface_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <memory>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosinterface_handler/utilities.hpp>
#ifdef MESSAGE_FILTERS_FOUND
#include <message_filters/subscriber.h>
#include <std_msgs/Header.h>
#else
#error message_filters was not found during compilation. Please recompile with message_filters.
#endif
#ifdef DYNAMIC_RECONFIGURE_FOUND
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"
#include <path_generator_ros_tool/PathGeneratorConfig.h>
#pragma GCC diagnostic pop
#else
struct PathGeneratorConfig{};
#endif


namespace path_generator_ros_tool {

/// \brief Parameter struct generated by rosinterface_handler
struct PathGeneratorInterface {

  using Config = PathGeneratorConfig;
#ifdef MESSAGE_FILTERS_FOUND
  template<typename T>
  using Subscriber = message_filters::Subscriber<T>;
  template<typename T>
  using SubscriberPtr = std::shared_ptr<Subscriber<T>>;
#endif
#ifdef IF_HANDLER_DIAGNOSTICS_INCLUDED
  template<typename T>
  using DiagSubscriber = rosinterface_handler::DiagnosedSubscriber<T>;
  template<typename T>
  using DiagSubscriberPtr = std::shared_ptr<DiagSubscriber<T>>;
  template<typename T>
  using DiagPublisher = rosinterface_handler::DiagnosedPublisher<T>;
#endif

  PathGeneratorInterface(const ros::NodeHandle& private_node_handle)
  : globalNamespace_{"/"},
    publicNamespace_{rosinterface_handler::getParentNamespace(private_node_handle) + "/"},
    privateNamespace_{private_node_handle.getNamespace() + "/"},
    nodeName_{rosinterface_handler::getNodeName(private_node_handle)},
    privateNodeHandle_{private_node_handle},
    dummy_subscriber{std::make_shared<Subscriber<std_msgs::Header>>()} {}

  /// \brief Get values from parameter server
  ///
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
    success &= rosinterface_handler::getParam(privateNamespace_ + "verbosity", verbosity, std::string{"debug"});
    rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_debug");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_info");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_warning");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_error");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_fatal");
    success &= rosinterface_handler::getParam(privateNamespace_ + "input_distance", input_distance, double{0.05});
    success &= rosinterface_handler::getParam(privateNamespace_ + "weight", weight, double{0.2});
    success &= rosinterface_handler::getParam(privateNamespace_ + "output_distance", output_distance, double{0.02});
    success &= rosinterface_handler::getParam(privateNamespace_ + "frame_id_map", frame_id_map, std::string{"map"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "bag_file_name", bag_file_name);
    success &= rosinterface_handler::getParam(privateNamespace_ + "frame_id_vehicle", frame_id_vehicle, std::string{"vehicle"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "frame_id_camera", frame_id_camera, std::string{"camera_top"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "frame_id_stargazer", frame_id_stargazer, std::string{"stargazer"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "path_to_map", path_to_map);
    success &= rosinterface_handler::getParam(privateNamespace_ + "error_cost", error_cost, double{700});
    success &= rosinterface_handler::getParam(privateNamespace_ + "points_per_circle", points_per_circle, double{150});
    success &= rosinterface_handler::getParam(privateNamespace_ + "curvature_estimate_region", curvature_estimate_region, double{30});
    success &= rosinterface_handler::getParam(privateNamespace_ + "dummy_subscriber_topic", dummy_subscriber_topic, std::string{"in_topic"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "dummy_subscriber_queue_size", dummy_subscriber_queue_size, int{5});
    success &= rosinterface_handler::getParam(privateNamespace_ + "dummy_publisher_topic", dummy_publisher_topic, std::string{"out_topic"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "dummy_publisher_queue_size", dummy_publisher_queue_size, int{5});

    dummy_subscriber->subscribe(privateNodeHandle_, rosinterface_handler::getTopic(privateNamespace_, dummy_subscriber_topic), uint32_t(dummy_subscriber_queue_size), ros::TransportHints().tcpNoDelay());
    dummy_publisher = privateNodeHandle_.advertise<std_msgs::Header>(rosinterface_handler::getTopic(privateNamespace_, dummy_publisher_topic), dummy_publisher_queue_size);

    rosinterface_handler::testMin<double>(privateNamespace_ + "input_distance", input_distance, 0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "input_distance", input_distance, 0.2);
    rosinterface_handler::testMin<double>(privateNamespace_ + "weight", weight, 0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "weight", weight, 1);
    rosinterface_handler::testMin<double>(privateNamespace_ + "output_distance", output_distance, 0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "output_distance", output_distance, 0.2);
    rosinterface_handler::testMin<double>(privateNamespace_ + "error_cost", error_cost, 100);
    rosinterface_handler::testMax<double>(privateNamespace_ + "error_cost", error_cost, 1000);
    rosinterface_handler::testMin<double>(privateNamespace_ + "points_per_circle", points_per_circle, 20);
    rosinterface_handler::testMax<double>(privateNamespace_ + "points_per_circle", points_per_circle, 500);
    rosinterface_handler::testMin<double>(privateNamespace_ + "curvature_estimate_region", curvature_estimate_region, 0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "curvature_estimate_region", curvature_estimate_region, 100);
    rosinterface_handler::testMin<int>(privateNamespace_ + "dummy_subscriber_queue_size", dummy_subscriber_queue_size, 0);
    rosinterface_handler::testMin<int>(privateNamespace_ + "dummy_publisher_queue_size", dummy_publisher_queue_size, 0);
    if(!success){
      missingParamsWarning();
      rosinterface_handler::exit("RosinterfaceHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
    rosinterface_handler::setParam(privateNamespace_ + "verbosity",verbosity);
    rosinterface_handler::setParam(privateNamespace_ + "input_distance",input_distance);
    rosinterface_handler::setParam(privateNamespace_ + "weight",weight);
    rosinterface_handler::setParam(privateNamespace_ + "output_distance",output_distance);
    rosinterface_handler::setParam(privateNamespace_ + "frame_id_map",frame_id_map);
    rosinterface_handler::setParam(privateNamespace_ + "bag_file_name",bag_file_name);
    rosinterface_handler::setParam(privateNamespace_ + "frame_id_vehicle",frame_id_vehicle);
    rosinterface_handler::setParam(privateNamespace_ + "frame_id_camera",frame_id_camera);
    rosinterface_handler::setParam(privateNamespace_ + "frame_id_stargazer",frame_id_stargazer);
    rosinterface_handler::setParam(privateNamespace_ + "path_to_map",path_to_map);
    rosinterface_handler::setParam(privateNamespace_ + "error_cost",error_cost);
    rosinterface_handler::setParam(privateNamespace_ + "points_per_circle",points_per_circle);
    rosinterface_handler::setParam(privateNamespace_ + "curvature_estimate_region",curvature_estimate_region);
    rosinterface_handler::setParam(privateNamespace_ + "dummy_subscriber_topic",dummy_subscriber_topic);
    rosinterface_handler::setParam(privateNamespace_ + "dummy_subscriber_queue_size",dummy_subscriber_queue_size);
    rosinterface_handler::setParam(privateNamespace_ + "dummy_publisher_topic",dummy_publisher_topic);
    rosinterface_handler::setParam(privateNamespace_ + "dummy_publisher_queue_size",dummy_publisher_queue_size);
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND
    if(dummy_subscriber_topic != config.dummy_subscriber_topic || dummy_subscriber_queue_size != config.dummy_subscriber_queue_size) {
      dummy_subscriber->subscribe(privateNodeHandle_, rosinterface_handler::getTopic(privateNamespace_, config.dummy_subscriber_topic), uint32_t(config.dummy_subscriber_queue_size), ros::TransportHints().tcpNoDelay());
    }
    if(dummy_publisher_topic != config.dummy_publisher_topic || dummy_publisher_queue_size != config.dummy_publisher_queue_size) {
      dummy_publisher = privateNodeHandle_.advertise<std_msgs::Header>(rosinterface_handler::getTopic(privateNamespace_, config.dummy_publisher_topic), config.dummy_publisher_queue_size);
    }
    if(config.verbosity != this->verbosity) {
        rosinterface_handler::setParam(privateNamespace_ + "verbosity", config.verbosity);
        rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity");
    }
    verbosity = config.verbosity;
    dummy_subscriber_topic = config.dummy_subscriber_topic;
    dummy_subscriber_queue_size = config.dummy_subscriber_queue_size;
    dummy_publisher_topic = config.dummy_publisher_topic;
    dummy_publisher_queue_size = config.dummy_publisher_queue_size;
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosinterface_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const PathGeneratorInterface& p)
  {
    os << "[" << p.nodeName_ << "]\nNode " << p.nodeName_ << " has the following parameters:\n"
      << "	" << p.privateNamespace_ << "verbosity:" << p.verbosity << "\n"
      << "	" << p.privateNamespace_ << "verbosity_debug:" << p.verbosity_debug << "\n"
      << "	" << p.privateNamespace_ << "verbosity_info:" << p.verbosity_info << "\n"
      << "	" << p.privateNamespace_ << "verbosity_warning:" << p.verbosity_warning << "\n"
      << "	" << p.privateNamespace_ << "verbosity_error:" << p.verbosity_error << "\n"
      << "	" << p.privateNamespace_ << "verbosity_fatal:" << p.verbosity_fatal << "\n"
      << "	" << p.privateNamespace_ << "input_distance:" << p.input_distance << "\n"
      << "	" << p.privateNamespace_ << "weight:" << p.weight << "\n"
      << "	" << p.privateNamespace_ << "output_distance:" << p.output_distance << "\n"
      << "	" << p.privateNamespace_ << "frame_id_map:" << p.frame_id_map << "\n"
      << "	" << p.privateNamespace_ << "bag_file_name:" << p.bag_file_name << "\n"
      << "	" << p.privateNamespace_ << "frame_id_vehicle:" << p.frame_id_vehicle << "\n"
      << "	" << p.privateNamespace_ << "frame_id_camera:" << p.frame_id_camera << "\n"
      << "	" << p.privateNamespace_ << "frame_id_stargazer:" << p.frame_id_stargazer << "\n"
      << "	" << p.privateNamespace_ << "path_to_map:" << p.path_to_map << "\n"
      << "	" << p.privateNamespace_ << "error_cost:" << p.error_cost << "\n"
      << "	" << p.privateNamespace_ << "points_per_circle:" << p.points_per_circle << "\n"
      << "	" << p.privateNamespace_ << "curvature_estimate_region:" << p.curvature_estimate_region << "\n"
      << "	" << p.privateNamespace_ << "dummy_subscriber_topic:" << p.dummy_subscriber_topic << "\n"
      << "	" << p.privateNamespace_ << "dummy_subscriber_queue_size:" << p.dummy_subscriber_queue_size << "\n"
      << "	" << p.privateNamespace_ << "dummy_publisher_topic:" << p.dummy_publisher_topic << "\n"
      << "	" << p.privateNamespace_ << "dummy_publisher_queue_size:" << p.dummy_publisher_queue_size << "\n"
;
    return os;
  }

  /// \brief get the node handle that the interface struct uses internally
  ros::NodeHandle getPrivateNodeHandle() {
      return privateNodeHandle_;
  }

  /// \brief returns the name of the node (works in nodelets, too)
  const std::string& nodeName() {
      return nodeName_;
  }
private:
  const std::string globalNamespace_;
  const std::string publicNamespace_;
  const std::string privateNamespace_;
  const std::string nodeName_;
  ros::NodeHandle privateNodeHandle_;

public:
  std::string verbosity; /*!< Sets the verbosity for this node */
  static constexpr auto verbosity_debug = "debug"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_info = "info"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_warning = "warning"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_error = "error"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_fatal = "fatal"; /*!< Constant for enum verbosity */
  double input_distance; /*!< define a distance to homogenize sample points */
  double weight; /*!< weight for moving average */
  double output_distance; /*!< output distance between points */
  std::string frame_id_map; /*!< Map frame ID */
  std::string bag_file_name; /*!< File name of rosbag containing /tf record */
  std::string frame_id_vehicle; /*!< Vehicle frame ID */
  std::string frame_id_camera; /*!< Top camera frame ID */
  std::string frame_id_stargazer; /*!< Stargazer frame ID */
  std::string path_to_map; /*!< directory to save road map */
  double error_cost; /*!< Cornu::Parameters::ERROR_COST */
  double points_per_circle; /*!< Cornu::Parameters::POINTS_PER_CIRCLE */
  double curvature_estimate_region; /*!< Cornu::Parameters::CURVATURE_ESTIMATE_REGION */
  std::string dummy_subscriber_topic; /*!< Topic for example subscriber */
  int dummy_subscriber_queue_size; /*!< Queue size for example subscriber */
  std::string dummy_publisher_topic; /*!< Topic for example publisher */
  int dummy_publisher_queue_size; /*!< Queue size for example publisher */
  ros::Publisher dummy_publisher; /*!< example publisher */
  SubscriberPtr<std_msgs::Header> dummy_subscriber; /*!< example subscriber */

private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName_ << "]\nThe following parameters do not have default values and need to be specified:\n"
      << "	" << privateNamespace_ << "bag_file_name" << " (std::string) \n"
      << "	" << privateNamespace_ << "path_to_map" << " (std::string) \n"
    );
  }
};

} // namespace path_generator_ros_tool
